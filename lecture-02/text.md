# Про отладку

Конспект [конспекта](https://bespoyasov.ru/blog/debug-it/) книги Пола Батчера [Debug it! Find, Repair, and Prevent Bugs in Your Code](https://www.amazon.com/Debug-Repair-Prevent-Pragmatic-Programmers/dp/193435628X)

## Глава 1. Посреди безумия

Отдебажить — это больше, чем «сделать так, чтобы баг исчез». Составляющие эффективного дебагинга:

- понять, почему программа ведёт себя не так, как ожидается;
- исправить ошибку;
- не поломать ничего по дороге;
- не испортить качество кода: читаемость, архитектуру, покрытие тестами и др.;
- принять меры, чтобы подобная проблема не появлялась в будущем.

Не стоит начинать писать заплатку, не разобравшись, что происходит. Это плохо, потому что может поломать то, что работало.

Понять проблему помогают наблюдения. Можно относительно просто провести эксперимент и посмотреть, как работает код.

Дебагинг состоит из 4 этапов:

- _воспроизвести_, найти способ точно и удобно воспроизвести проблему;
- _определить причину_, построить гипотезу проблемы и протестировать её на экспериментах;
- _починить проблему_, не ломая поведение других частей программы;
- _подумать, как предупредить_, что сделать, чтобы не допускать подобных проблем в будущем.

Перед тем, как пробовать воспроизвести проблему, надо определиться, как программа должна работать, и что именно происходит не правильно.

Исправляйть ошибки следует одну за одной, не пытаясь решить несколько проблем за раз. Ошибки могут быть связаны, если чинить всё разом, можно эти связи упустить.

## Глава 2. Воспроизвести

Если проблему нельзя воспроизвести, то её нельзя починить.

Если есть баг‑репорт, повторите шаги оттуда. При этом не забывайте контролировать и сверять

- _версию браузера_,
- _версию ОС_,
- _вводимые данные_ (не забывайте про пограничные значения),
- _версию API_
- _версию вашего приложения_.

Воспроизведение ошибок должно быть не только точным, но и удобным. Поэтому надо убирать лишние шаги, которые не относятся к проблеме. Чем короче путь до проблемы, тем проще её решать.

Есть "плавающие" баги, которые иногда появляются, иногда нет. // TODO

## Глава 3. Определить причину

Когда удалось воспроизвести проблему, нужно заново понять, как именно код работает.

Для этого необходимо строить гипотезы о причинах нежелательного поведения и проводить эксперименты.

Проводить эксперименты лучше в "чистой" ветке, чтобы всегда можно было отследить, что именно вы меняли.

Перед каждым экспериментом лучше понимать, что именно вы пытаетесь проверить, потому что иначе эксперимент бесполезен.

Результат эксперимента может согласовываться с определенной гипотезой (слабое свидетельство в пользу гипотезы), а может опровергать её (сильное свидетельство против гипотезы).

Базовое правило для эксперимента — одно изменение в программе за раз. Множественные изменения могут привести к неправильным выводам.

Не игнорируйте странности. Всё, что вы не понимаете — потенциально баг.

Используйте "бинарный поиск" для определения места, откуда идёт проблема.

Анализируйте, правильную ли часть программы или окружения вы изменяете. Если в результате ничего не меняется, то вы меняете не то, что собирались изменить.

Попробуйте объяснить проблему кому‑то, попробуйте её записать. Отдохните.

## Глава 4. Исправить проблему

Начинайте писать фиксы в чистой ветке.

Перед началом проверьте, что имеющиеся тесты проходят — это нужно для уверенности, что фикс не поломал другую функциональность. Если автотестов нет, то можно их написать или хотя бы представить и зафиксировать план ручного тестирования исправления.

Вам в любом случае нужен тест, который будет падать, демонстрируя проблему, и который будет проходить после исправления, демонстрируя успешность правок.

Исправляйте причину, а не следствия ошибки. Чтобы добраться до причины, надо полностью понять проблему. Если во время объяснения вы произносите нечто вроде «по какой‑то причине» или «не особо ясно, почему здесь так», то до корня проблемы вы ещё не добрались, и фикс не починит её полностью.

Никогда не проводите рефакторинг совместно с фиксом ошибки. Либо вы чините код, либо рефакторите.

## Глава 5. Не допускать такой ошибки в будущем

Примите меры, чтобы подобные ошибки не случались в будущем: проверьте похожие места, напишите тесты.

Проверьте, что решение проблемы соответствует кодстайлу и архитектуре.

## Глава 6. Определяем, что у нас проблемы

В идеальном мире баги проходят через баг-трекер. Это дает более или менее стандартное описание багов, позволяет видеть приоритеты, хранить историю и, возможно, причины, по котороым могли отказаться исправлять тот или иной баг.

### Глава 7. Прагматичная нетерпимость к багам

Баги надо чинить в первую очередь, это уменьшает неопределённость и технический долг. Чем больше багов будет копиться, тем более пофиг на них будет — такого допускать нельзя.

Между «ой да плевать, пусть идёт как идёт» и «в проекте всё будет идеально вылизано» следует выбирать нечто посередине, чуть ближе к правому краю: ￼

<img src="./assets/zero-tolerance.jpg" alt="fatalism-vs-perfectionism" width="500px" />

Быстрых фиксов не существует — разбираться в проблеме придётся каждый раз. Чтобы было проще:

- настройте систему версий, сборку проекта, автотесты, CI, CD;
- отделите хороший код: чистый, оттестированный, отдебаженный — от плохого.


### Глава 9. Идеальное окружение для отладки

У вас должны быть автотесты. Критерии хороших тестов:

- Вы должны доверять своим тестам. Если они падают — на то должна быть причина. Если тест иногда падает, иногда нет, доверять ему не будут.
- Тест не должен требовать ручной настройки окружения. Ему оно либо не нужно, либо окружение настраивается автоматически.
- Тест не должен зависеть от других тестов. Он полностью независим оттого, сколько и какие тесты в наборе, а также от хода и результатов выполнения других тестов.
- Тесты должны покрывать как минимум всю важную часть логики и компонентов программы. 


# Про Git

Есть набор процедур, которые исполняет каждый участник команды, чтобы все вместе могли достичь высокой управляемости процесса разработки.

У нас есть "центральный" репозиторий origin. Каждый разработчик забирает и публикует изменения (pull & push) в origin.

Центральный репозиторий содержит две главные ветки, существующие всё время:

- master
- develop

Исходный код в origin/master должен находиться в состоянии production-ready в любой произвольный момент времени.

Ветка origin/develop считается главной для разработки. Хранящийся в ней код в любой момент времени должен содержать самые последние изданные изменения, необходимые для следующего релиза.

Когда исходный код в ветке разработки (develop) достигает стабильного состояния и готов к релизу, все изменения должны быть определённым способом влиты в главную ветку (master) и помечены тегом с номером релиза.

Помимо главных ветвей master и develop существует несколько типов вспомогательных ветвей, которые используются для распараллеливания разработки, для подготовки релизов и для быстрого исправления проблем в производственной версии приложения.

- Ветви функциональностей (Feature branches)
- Ветви релизов (Release branches)
- Ветви исправлений (Hotfix branches)

У каждого типа ветвей есть свой срок жизни, специфическое назначение и строгий набор правил, от каких ветвей они могут порождаться, и в какие должны вливаться.


### Ветви функциональностей (feature branches)


Могут порождаться от: develop
Должны вливаться в: develop
Соглашение о наименовании: всё, за исключением master, develop, release-* или hotfix-*

Живёт так долго, сколько продолжается разработка данной фичи. Когда работа в ветке завершена, вливается обратно в develop (что означает, что функциональность будет добавлена в грядущий релиз) или же удаляется (в случае неудачного эксперимента).

#### Вливание в develop

Merge VS Rebase

Некоторые предпочитают делать `merge`, причем с флагом `--no-ff`:

`$ git merge --no-ff myfeature`

Флаг --no-ff вынуждает Git всегда создавать новый объект коммита при слиянии, даже если слияние может быть осуществлено алгоритмом fast-forward. Это позволяет не терять информацию о том, что ветка существовала, и группирует вместе все внесённые изменения.

Некоторые предпочитают fast-forward.

Некоторые предпочитают делать `rebase`, потому что стремятся к краткой и линейной истории изменений.

С помощью `rebase` можно взять все коммиты из одной ветки и повторить их на другой.

```
$ git checkout myfeature
$ git rebase develop
```

Можно выполнить интерактивный `rebase`:

```
$ git checkout myfeature
$ git rebase -i develop
```


Если вы пользуетесь системой контроля версий, то каждое следует комитить каждое логическое изменение, причём одно за раз.

Чаще давайте свои решения на ревью.

git: bisect, rebase, squash, git flow, линтеры, ide, техники дебага
